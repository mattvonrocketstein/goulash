<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>goulash.reflect API documentation</title>
    <meta name="description" content="Standardized versions of various cool and/or strange things that you can do
with Python's reflection..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#goulash.reflect.IS">IS</a></li>
    <li class="mono"><a href="#goulash.reflect.ISNT">ISNT</a></li>
    <li class="mono"><a href="#goulash.reflect.WAS">WAS</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#goulash.reflect.accumulateBases">accumulateBases</a></li>
    <li class="mono"><a href="#goulash.reflect.accumulateClassDict">accumulateClassDict</a></li>
    <li class="mono"><a href="#goulash.reflect.accumulateClassList">accumulateClassList</a></li>
    <li class="mono"><a href="#goulash.reflect.addMethodNamesToDict">addMethodNamesToDict</a></li>
    <li class="mono"><a href="#goulash.reflect.filenameToModuleName">filenameToModuleName</a></li>
    <li class="mono"><a href="#goulash.reflect.findInstances">findInstances</a></li>
    <li class="mono"><a href="#goulash.reflect.fullFuncName">fullFuncName</a></li>
    <li class="mono"><a href="#goulash.reflect.funcinfo">funcinfo</a></li>
    <li class="mono"><a href="#goulash.reflect.getClass">getClass</a></li>
    <li class="mono"><a href="#goulash.reflect.getcurrent">getcurrent</a></li>
    <li class="mono"><a href="#goulash.reflect.isLike">isLike</a></li>
    <li class="mono"><a href="#goulash.reflect.isOfType">isOfType</a></li>
    <li class="mono"><a href="#goulash.reflect.isSame">isSame</a></li>
    <li class="mono"><a href="#goulash.reflect.isinst">isinst</a></li>
    <li class="mono"><a href="#goulash.reflect.modgrep">modgrep</a></li>
    <li class="mono"><a href="#goulash.reflect.namedAny">namedAny</a></li>
    <li class="mono"><a href="#goulash.reflect.namedClass">namedClass</a></li>
    <li class="mono"><a href="#goulash.reflect.namedModule">namedModule</a></li>
    <li class="mono"><a href="#goulash.reflect.namedObject">namedObject</a></li>
    <li class="mono"><a href="#goulash.reflect.objgrep">objgrep</a></li>
    <li class="mono"><a href="#goulash.reflect.prefixedMethodNames">prefixedMethodNames</a></li>
    <li class="mono"><a href="#goulash.reflect.prefixedMethods">prefixedMethods</a></li>
    <li class="mono"><a href="#goulash.reflect.qual">qual</a></li>
    <li class="mono"><a href="#goulash.reflect.safe_repr">safe_repr</a></li>
    <li class="mono"><a href="#goulash.reflect.safe_str">safe_str</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.Accessor">Accessor</a></span>
        
          
  <ul>
    <li class="mono"><a href="#goulash.reflect.Accessor.reallyDel">reallyDel</a></li>
    <li class="mono"><a href="#goulash.reflect.Accessor.reallySet">reallySet</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.AccessorType">AccessorType</a></span>
        
          
  <ul>
    <li class="mono"><a href="#goulash.reflect.AccessorType.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.InvalidName">InvalidName</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.ModuleNotFound">ModuleNotFound</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.ObjectNotFound">ObjectNotFound</a></span>
        
        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.Accessor">Accessor</a></span>
        
          
  <ul>
    <li class="mono"><a href="#goulash.reflect.Accessor.reallyDel">reallyDel</a></li>
    <li class="mono"><a href="#goulash.reflect.Accessor.reallySet">reallySet</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.PropertyAccessor">PropertyAccessor</a></span>
        
          
  <ul>
    <li class="mono"><a href="#goulash.reflect.PropertyAccessor.reallyDel">reallyDel</a></li>
    <li class="mono"><a href="#goulash.reflect.PropertyAccessor.reallySet">reallySet</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.QueueMethod">QueueMethod</a></span>
        
          
  <ul>
    <li class="mono"><a href="#goulash.reflect.QueueMethod.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.Settable">Settable</a></span>
        
          
  <ul>
    <li class="mono"><a href="#goulash.reflect.Settable.__init__">__init__</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#goulash.reflect.Summer">Summer</a></span>
        
          
  <ul>
    <li class="mono"><a href="#goulash.reflect.Summer.reallyDel">reallyDel</a></li>
    <li class="mono"><a href="#goulash.reflect.Summer.reallySet">reallySet</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">goulash.reflect</span> module</h1>
  <p>Standardized versions of various cool and/or strange things that you can do
with Python's reflection capabilities.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect" class="source">
    <pre><code># Copyright (c) 2001-2010 Twisted Matrix Laboratories.
# See LICENSE for details.

"""
Standardized versions of various cool and/or strange things that you can do
with Python's reflection capabilities.
"""

import sys
import os
import types
import pickle
import traceback
import weakref
import re
import warnings

try:
    from collections import deque
except ImportError:
    deque = list

RegexType = type(re.compile(""))

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO


class Settable:
    """
    A mixin class for syntactic sugar.  Lets you assign attributes by
    calling with keyword arguments; for example, C{x(a=b,c=d,y=z)} is the
    same as C{x.a=b;x.c=d;x.y=z}.  The most useful place for this is
    where you don't want to name a variable, but you do want to set
    some attributes; for example, C{X()(y=z,a=b)}.
    """
    def __init__(self, **kw):
        self(**kw)

    def __call__(self,**kw):
        for key,val in kw.items():
            setattr(self,key,val)
        return self

class AccessorType(type):
    """Metaclass that generates properties automatically.

    This is for Python 2.2 and up.

    Using this metaclass for your class will give you explicit accessor
    methods; a method called set_foo, will automatically create a property
    'foo' that uses set_foo as a setter method. Same for get_foo and del_foo.

    Note that this will only work on methods that are present on class
    creation. If you add methods after the class is defined they will not
    automatically become properties. Likewise, class attributes will only
    be used if they are present upon class creation, and no getter function
    was set - if a getter is present, the class attribute will be ignored.

    This is a 2.2-only alternative to the Accessor mixin - just set in your
    class definition::

        __metaclass__ = AccessorType

    """

    def __init__(self, name, bases, d):
        type.__init__(self, name, bases, d)
        accessors = {}
        prefixs = ["get_", "set_", "del_"]
        for k in d.keys():
            v = getattr(self, k)
            for i in range(3):
                if k.startswith(prefixs[i]):
                    accessors.setdefault(k[4:], [None, None, None])[i] = v
        for name, (getter, setter, deler) in accessors.items():
            # create default behaviours for the property - if we leave
            # the getter as None we won't be able to getattr, etc..
            if getter is None:
                if hasattr(self, name):
                    value = getattr(self, name)
                    def getter(this, value=value, name=name):
                        if name in this.__dict__:
                            return this.__dict__[name]
                        else:
                            return value
                else:
                    def getter(this, name=name):
                        if name in this.__dict__:
                            return this.__dict__[name]
                        else:
                            raise AttributeError("no such attribute %r" % name)
            if setter is None:
                def setter(this, value, name=name):
                    this.__dict__[name] = value
            if deler is None:
                def deler(this, name=name):
                    del this.__dict__[name]
            setattr(self, name, property(getter, setter, deler, ""))


class PropertyAccessor(object):
    """A mixin class for Python 2.2 that uses AccessorType.

    This provides compatability with the pre-2.2 Accessor mixin, up
    to a point.

    Extending this class will give you explicit accessor methods; a
    method called set_foo, for example, is the same as an if statement
    in __setattr__ looking for 'foo'.  Same for get_foo and del_foo.

    There are also reallyDel and reallySet methods, so you can
    override specifics in subclasses without clobbering __setattr__
    and __getattr__, or using non-2.1 compatible code.

    There is are incompatibilities with Accessor - accessor
    methods added after class creation will *not* be detected. OTOH,
    this method is probably way faster.

    In addition, class attributes will only be used if no getter
    was defined, and instance attributes will not override getter methods
    whereas in original Accessor the class attribute or instance attribute
    would override the getter method.
    """
    # addendum to above:
    # The behaviour of Accessor is wrong IMHO, and I've found bugs
    # caused by it.
    #  -- itamar

    __metaclass__ = AccessorType

    def reallySet(self, k, v):
        self.__dict__[k] = v

    def reallyDel(self, k):
        del self.__dict__[k]


class Accessor:
    """
    Extending this class will give you explicit accessor methods; a
    method called C{set_foo}, for example, is the same as an if statement
    in L{__setattr__} looking for C{'foo'}.  Same for C{get_foo} and
    C{del_foo}.  There are also L{reallyDel} and L{reallySet} methods,
    so you can override specifics in subclasses without clobbering
    L{__setattr__} and L{__getattr__}.

    This implementation is for Python 2.1.
    """

    def __setattr__(self, k,v):
        kstring='set_%s'%k
        if hasattr(self.__class__,kstring):
            return getattr(self,kstring)(v)
        else:
            self.reallySet(k,v)

    def __getattr__(self, k):
        kstring='get_%s'%k
        if hasattr(self.__class__,kstring):
            return getattr(self,kstring)()
        raise AttributeError("%s instance has no accessor for: %s" % (qual(self.__class__),k))

    def __delattr__(self, k):
        kstring='del_%s'%k
        if hasattr(self.__class__,kstring):
            getattr(self,kstring)()
            return
        self.reallyDel(k)

    def reallySet(self, k,v):
        """
        *actually* set self.k to v without incurring side-effects.
        This is a hook to be overridden by subclasses.
        """
        if k == "__dict__":
            self.__dict__.clear()
            self.__dict__.update(v)
        else:
            self.__dict__[k]=v

    def reallyDel(self, k):
        """
        *actually* del self.k without incurring side-effects.  This is a
        hook to be overridden by subclasses.
        """
        del self.__dict__[k]

# just in case
OriginalAccessor = Accessor


class Summer(Accessor):
    """
    Extend from this class to get the capability to maintain 'related
    sums'.  Have a tuple in your class like the following::

        sums=(('amount','credit','credit_total'),
            ('amount','debit','debit_total'))

    and the 'credit_total' member of the 'credit' member of self will
    always be incremented when the 'amount' member of self is
    incremented, similiarly for the debit versions.
    """

    def reallySet(self, k,v):
        "This method does the work."
        for sum in self.sums:
            attr=sum[0]
            obj=sum[1]
            objattr=sum[2]
            if k == attr:
                try:
                    oldval=getattr(self, attr)
                except:
                    oldval=0
                diff=v-oldval
                if hasattr(self, obj):
                    ob=getattr(self,obj)
                    if ob is not None:
                        try:oldobjval=getattr(ob, objattr)
                        except:oldobjval=0.0
                        setattr(ob,objattr,oldobjval+diff)

            elif k == obj:
                if hasattr(self, attr):
                    x=getattr(self,attr)
                    setattr(self,attr,0)
                    y=getattr(self,k)
                    Accessor.reallySet(self,k,v)
                    setattr(self,attr,x)
                    Accessor.reallySet(self,y,v)
        Accessor.reallySet(self,k,v)


class QueueMethod:
    """ I represent a method that doesn't exist yet."""
    def __init__(self, name, calls):
        self.name = name
        self.calls = calls
    def __call__(self, *args):
        self.calls.append((self.name, args))


def funcinfo(function):
    """
    this is more documentation for myself than useful code.
    """
    warnings.warn(
        "[v2.5] Use inspect.getargspec instead of twisted.python.reflect.funcinfo",
        DeprecationWarning,
        stacklevel=2)
    code=function.func_code
    name=function.func_name
    argc=code.co_argcount
    argv=code.co_varnames[:argc]
    defaults=function.func_defaults

    out = []

    out.append('The function %s accepts %s arguments' % (name ,argc))
    if defaults:
        required=argc-len(defaults)
        out.append('It requires %s arguments' % required)
        out.append('The arguments required are: %s' % argv[:required])
        out.append('additional arguments are:')
        for i in range(argc-required):
            j=i+required
            out.append('%s which has a default of' % (argv[j], defaults[i]))
    return out


ISNT=0
WAS=1
IS=2


def fullFuncName(func):
    qualName = (str(pickle.whichmodule(func, func.__name__)) + '.' + func.__name__)
    if namedObject(qualName) is not func:
        raise Exception("Couldn't find %s as %s." % (func, qualName))
    return qualName


def qual(clazz):
    """Return full import path of a class."""
    return clazz.__module__ + '.' + clazz.__name__


def getcurrent(clazz):
    assert type(clazz) == types.ClassType, 'must be a class...'
    module = namedModule(clazz.__module__)
    currclass = getattr(module, clazz.__name__, None)
    if currclass is None:
        return clazz
    return currclass


def getClass(obj):
    """Return the class or type of object 'obj'.
    Returns sensible result for oldstyle and newstyle instances and types."""
    if hasattr(obj, '__class__'):
        return obj.__class__
    else:
        return type(obj)

# class graph nonsense

# I should really have a better name for this...
def isinst(inst,clazz):
    if type(inst) != types.InstanceType or type(clazz)!= types.ClassType:
        return isinstance(inst,clazz)
    cl = inst.__class__
    cl2 = getcurrent(cl)
    clazz = getcurrent(clazz)
    if issubclass(cl2,clazz):
        if cl == cl2:
            return WAS
        else:
            inst.__class__ = cl2
            return IS
    else:
        return ISNT


def namedModule(name):
    """Return a module given its name."""
    topLevel = __import__(name)
    packages = name.split(".")[1:]
    m = topLevel
    for p in packages:
        m = getattr(m, p)
    return m


def namedObject(name):
    """Get a fully named module-global object.
    """
    classSplit = name.split('.')
    module = namedModule('.'.join(classSplit[:-1]))
    return getattr(module, classSplit[-1])

namedClass = namedObject # backwards compat



class _NoModuleFound(Exception):
    """
    No module was found because none exists.
    """


class InvalidName(ValueError):
    """
    The given name is not a dot-separated list of Python objects.
    """


class ModuleNotFound(InvalidName):
    """
    The module associated with the given name doesn't exist and it can't be
    imported.
    """


class ObjectNotFound(InvalidName):
    """
    The object associated with the given name doesn't exist and it can't be
    imported.
    """


def _importAndCheckStack(importName):
    """
    Import the given name as a module, then walk the stack to determine whether
    the failure was the module not existing, or some code in the module (for
    example a dependent import) failing.  This can be helpful to determine
    whether any actual application code was run.  For example, to distiguish
    administrative error (entering the wrong module name), from programmer
    error (writing buggy code in a module that fails to import).

    @raise Exception: if something bad happens.  This can be any type of
    exception, since nobody knows what loading some arbitrary code might do.

    @raise _NoModuleFound: if no module was found.
    """
    try:
        try:
            return __import__(importName)
        except ImportError:
            excType, excValue, excTraceback = sys.exc_info()
            while excTraceback:
                execName = excTraceback.tb_frame.f_globals["__name__"]
                if (execName is None or # python 2.4+, post-cleanup
                    execName == importName): # python 2.3, no cleanup
                    raise excType, excValue, excTraceback
                excTraceback = excTraceback.tb_next
            raise _NoModuleFound()
    except:
        # Necessary for cleaning up modules in 2.3.
        sys.modules.pop(importName, None)
        raise



def namedAny(name):
    """
    Retrieve a Python object by its fully qualified name from the global Python
    module namespace.  The first part of the name, that describes a module,
    will be discovered and imported.  Each subsequent part of the name is
    treated as the name of an attribute of the object specified by all of the
    name which came before it.  For example, the fully-qualified name of this
    object is 'twisted.python.reflect.namedAny'.

    @type name: L{str}
    @param name: The name of the object to return.

    @raise InvalidName: If the name is an empty string, starts or ends with
        a '.', or is otherwise syntactically incorrect.

    @raise ModuleNotFound: If the name is syntactically correct but the
        module it specifies cannot be imported because it does not appear to
        exist.

    @raise ObjectNotFound: If the name is syntactically correct, includes at
        least one '.', but the module it specifies cannot be imported because
        it does not appear to exist.

    @raise AttributeError: If an attribute of an object along the way cannot be
        accessed, or a module along the way is not found.

    @return: the Python object identified by 'name'.
    """
    if not name:
        raise InvalidName('Empty module name')

    names = name.split('.')

    # if the name starts or ends with a '.' or contains '..', the __import__
    # will raise an 'Empty module name' error. This will provide a better error
    # message.
    if '' in names:
        raise InvalidName(
            "name must be a string giving a '.'-separated list of Python "
            "identifiers, not %r" % (name,))

    topLevelPackage = None
    moduleNames = names[:]
    while not topLevelPackage:
        if moduleNames:
            trialname = '.'.join(moduleNames)
            try:
                topLevelPackage = _importAndCheckStack(trialname)
            except _NoModuleFound:
                moduleNames.pop()
        else:
            if len(names) == 1:
                raise ModuleNotFound("No module named %r" % (name,))
            else:
                raise ObjectNotFound('%r does not name an object' % (name,))

    obj = topLevelPackage
    for n in names[1:]:
        obj = getattr(obj, n)

    return obj




def _determineClass(x):
    try:
        return x.__class__
    except:
        return type(x)

def _determineClassName(x):
    c = _determineClass(x)
    try:
        return c.__name__
    except:
        try:
            return str(c)
        except:
            return '<BROKEN CLASS AT %s>' % str(c)


def _safeFormat(formatter, o):
    """
    Helper function for L{safe_repr} and L{safe_str}.
    """
    try:
        return formatter(o)
    except:
        io = StringIO()
        traceback.print_exc(file=io)
        className = _determineClassName(o)
        tbValue = io.getvalue()
        return "<%s instance at %s with %s error:\n %s>" % (
            className, str(o), formatter.__name__, tbValue)


def safe_repr(o):
    """
    safe_repr(anything) -> string

    Returns a string representation of an object, or a string containing a
    traceback, if that object's __repr__ raised an exception.
    """
    return _safeFormat(repr, o)


def safe_str(o):
    """
    safe_str(anything) -> string

    Returns a string representation of an object, or a string containing a
    traceback, if that object's __str__ raised an exception.
    """
    return _safeFormat(str, o)



def accumulateBases(classObj, l, baseClass=None):
    for base in classObj.__bases__:
        if baseClass is None or issubclass(base, baseClass):
            l.append(base)
        accumulateBases(base, l, baseClass)


def prefixedMethodNames(classObj, prefix):
    """A list of method names with a given prefix in a given class.
    """
    dct = {}
    addMethodNamesToDict(classObj, dct, prefix)
    return dct.keys()


def addMethodNamesToDict(classObj, dict, prefix, baseClass=None):
    """
    addMethodNamesToDict(classObj, dict, prefix, baseClass=None) -> dict
    this goes through 'classObj' (and its bases) and puts method names
    starting with 'prefix' in 'dict' with a value of 1. if baseClass isn't
    None, methods will only be added if classObj is-a baseClass

    If the class in question has the methods 'prefix_methodname' and
    'prefix_methodname2', the resulting dict should look something like:
    {"methodname": 1, "methodname2": 1}.
    """
    for base in classObj.__bases__:
        addMethodNamesToDict(base, dict, prefix, baseClass)

    if baseClass is None or baseClass in classObj.__bases__:
        for name, method in classObj.__dict__.items():
            optName = name[len(prefix):]
            if ((type(method) is types.FunctionType)
                and (name[:len(prefix)] == prefix)
                and (len(optName))):
                dict[optName] = 1


def prefixedMethods(obj, prefix=''):
    """A list of methods with a given prefix on a given instance.
    """
    dct = {}
    accumulateMethods(obj, dct, prefix)
    return dct.values()


def accumulateMethods(obj, dict, prefix='', curClass=None):
    """accumulateMethods(instance, dict, prefix)
    I recurse through the bases of instance.__class__, and add methods
    beginning with 'prefix' to 'dict', in the form of
    {'methodname':*instance*method_object}.
    """
    if not curClass:
        curClass = obj.__class__
    for base in curClass.__bases__:
        accumulateMethods(obj, dict, prefix, base)

    for name, method in curClass.__dict__.items():
        optName = name[len(prefix):]
        if ((type(method) is types.FunctionType)
            and (name[:len(prefix)] == prefix)
            and (len(optName))):
            dict[optName] = getattr(obj, name)

def accumulateClassDict(classObj, attr, adict, baseClass=None):
    """Accumulate all attributes of a given name in a class heirarchy into a single dictionary.

    Assuming all class attributes of this name are dictionaries.
    If any of the dictionaries being accumulated have the same key, the
    one highest in the class heirarchy wins.
    (XXX: If \"higest\" means \"closest to the starting class\".)

    Ex::

    | class Soy:
    |   properties = {\"taste\": \"bland\"}
    |
    | class Plant:
    |   properties = {\"colour\": \"green\"}
    |
    | class Seaweed(Plant):
    |   pass
    |
    | class Lunch(Soy, Seaweed):
    |   properties = {\"vegan\": 1 }
    |
    | dct = {}
    |
    | accumulateClassDict(Lunch, \"properties\", dct)
    |
    | print dct

    {\"taste\": \"bland\", \"colour\": \"green\", \"vegan\": 1}
    """
    for base in classObj.__bases__:
        accumulateClassDict(base, attr, adict)
    if baseClass is None or baseClass in classObj.__bases__:
        adict.update(classObj.__dict__.get(attr, {}))


def accumulateClassList(classObj, attr, listObj, baseClass=None):
    """Accumulate all attributes of a given name in a class
        heirarchy into a single list. Assuming all class attributes
        of this name are lists.
    """
    for base in classObj.__bases__:
        accumulateClassList(base, attr, listObj)
    if baseClass is None or baseClass in classObj.__bases__:
        listObj.extend(classObj.__dict__.get(attr, []))


def isSame(a, b):
    return (a is b)


def isLike(a, b):
    return (a == b)


def modgrep(goal):
    return objgrep(sys.modules, goal, isLike, 'sys.modules')


def isOfType(start, goal):
    return ((type(start) is goal) or
            (isinstance(start, types.InstanceType) and
             start.__class__ is goal))

def findInstances(start, t):
    return objgrep(start, t, isOfType)

def objgrep(start, goal, eq=isLike, path='', paths=None, seen=None, showUnknowns=0, maxDepth=None):
    '''An insanely CPU-intensive process for finding stuff.
    '''
    if paths is None:
        paths = []
    if seen is None:
        seen = {}
    if eq(start, goal):
        paths.append(path)
    if id(start) in seen:
        if seen[id(start)] is start:
            return
    if maxDepth is not None:
        if maxDepth == 0:
            return
        maxDepth -= 1
    seen[id(start)] = start
    if isinstance(start, types.DictionaryType):
        for k, v in start.items():
            objgrep(k, goal, eq,
                    path + '{' + repr(v) + '}', paths,
                    seen, showUnknowns, maxDepth)
            objgrep(v, goal, eq, path+'[' + repr(k) + ']',
                    paths, seen, showUnknowns, maxDepth)
    elif isinstance(start, (list, tuple, deque)):
        for idx in xrange(len(start)):
            objgrep(
                start[idx], goal, eq, path+'[' + str(idx) + ']',
                paths, seen, showUnknowns, maxDepth)
    elif isinstance(start, types.MethodType):
        objgrep(start.im_self, goal, eq, path + '.im_self',
                paths, seen, showUnknowns, maxDepth)
        objgrep(start.im_func, goal, eq, path + '.im_func',
                paths, seen, showUnknowns, maxDepth)
        objgrep(start.im_class, goal, eq, path + '.im_class',
                paths, seen, showUnknowns, maxDepth)
    elif hasattr(start, '__dict__'):
        for k, v in start.__dict__.items():
            objgrep(v, goal, eq, path+'.' + k, paths, seen,
                    showUnknowns, maxDepth)
        if isinstance(start, types.InstanceType):
            objgrep(start.__class__, goal, eq,
                    path + '.__class__', paths,
                    seen, showUnknowns, maxDepth)
    elif isinstance(start, weakref.ReferenceType):
        objgrep(start(), goal, eq, path + '()', paths,
                seen, showUnknowns, maxDepth)
    elif (isinstance(start, types.StringTypes +\
                     (types.IntType, types.FunctionType,
                      types.BuiltinMethodType, RegexType, types.FloatType,
                      types.NoneType, types.FileType)) or
          type(start).__name__ in ('wrapper_descriptor', 'method_descriptor',
                                   'member_descriptor', 'getset_descriptor')):
        pass
    elif showUnknowns:
        print 'unknown type', type(start), start
    return paths


def filenameToModuleName(fn):
    """
    Convert a name in the filesystem to the name of the Python module it is.

    This is agressive about getting a module name back from a file; it will
    always return a string.  Agressive means 'sometimes wrong'; it won't look
    at the Python path or try to do any error checking: don't use this method
    unless you already know that the filename you're talking about is a Python
    module.
    """
    fullName = os.path.abspath(fn)
    base = os.path.basename(fn)
    if not base:
        # this happens when fn ends with a path separator, just skit it
        base = os.path.basename(fn[:-1])
    modName = os.path.splitext(base)[0]
    while 1:
        fullName = os.path.dirname(fullName)
        if os.path.exists(os.path.join(fullName, "__init__.py")):
            modName = "%s.%s" % (os.path.basename(fullName), modName)
        else:
            break
    return modName
from_dotpath = namedAny

__all__ = [
    'InvalidName', 'ModuleNotFound', 'ObjectNotFound',
    'ISNT', 'WAS', 'IS',
    'Settable', 'AccessorType', 'PropertyAccessor', 'Accessor', 'Summer',
    'QueueMethod', 'OriginalAccessor',
    'funcinfo', 'fullFuncName', 'qual', 'getcurrent', 'getClass', 'isinst',
    'namedModule', 'namedObject', 'namedClass', 'namedAny',
    'safe_repr', 'safe_str', 'accumulateBases',
    'prefixedMethodNames', 'addMethodNamesToDict', 'prefixedMethods',
    'accumulateClassDict', 'accumulateClassList', 'isSame', 'isLike',
    'modgrep', 'isOfType', 'findInstances', 'objgrep', 'filenameToModuleName',
    ]
</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="goulash.reflect.IS" class="name">var <span class="ident">IS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="goulash.reflect.ISNT" class="name">var <span class="ident">ISNT</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="goulash.reflect.WAS" class="name">var <span class="ident">WAS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="goulash.reflect.accumulateBases">
    <p>def <span class="ident">accumulateBases</span>(</p><p>classObj, l, baseClass=None)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.accumulateBases', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.accumulateBases" class="source">
    <pre><code>def accumulateBases(classObj, l, baseClass=None):
    for base in classObj.__bases__:
        if baseClass is None or issubclass(base, baseClass):
            l.append(base)
        accumulateBases(base, l, baseClass)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.accumulateClassDict">
    <p>def <span class="ident">accumulateClassDict</span>(</p><p>classObj, attr, adict, baseClass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Accumulate all attributes of a given name in a class heirarchy into a single dictionary.</p>
<p>Assuming all class attributes of this name are dictionaries.
If any of the dictionaries being accumulated have the same key, the
one highest in the class heirarchy wins.
(XXX: If "higest" means "closest to the starting class".)</p>
<p>Ex::</p>
<p>| class Soy:
|   properties = {"taste": "bland"}
|
| class Plant:
|   properties = {"colour": "green"}
|
| class Seaweed(Plant):
|   pass
|
| class Lunch(Soy, Seaweed):
|   properties = {"vegan": 1 }
|
| dct = {}
|
| accumulateClassDict(Lunch, "properties", dct)
|
| print dct</p>
<p>{"taste": "bland", "colour": "green", "vegan": 1}</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.accumulateClassDict', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.accumulateClassDict" class="source">
    <pre><code>def accumulateClassDict(classObj, attr, adict, baseClass=None):
    """Accumulate all attributes of a given name in a class heirarchy into a single dictionary.

    Assuming all class attributes of this name are dictionaries.
    If any of the dictionaries being accumulated have the same key, the
    one highest in the class heirarchy wins.
    (XXX: If \"higest\" means \"closest to the starting class\".)

    Ex::

    | class Soy:
    |   properties = {\"taste\": \"bland\"}
    |
    | class Plant:
    |   properties = {\"colour\": \"green\"}
    |
    | class Seaweed(Plant):
    |   pass
    |
    | class Lunch(Soy, Seaweed):
    |   properties = {\"vegan\": 1 }
    |
    | dct = {}
    |
    | accumulateClassDict(Lunch, \"properties\", dct)
    |
    | print dct

    {\"taste\": \"bland\", \"colour\": \"green\", \"vegan\": 1}
    """
    for base in classObj.__bases__:
        accumulateClassDict(base, attr, adict)
    if baseClass is None or baseClass in classObj.__bases__:
        adict.update(classObj.__dict__.get(attr, {}))
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.accumulateClassList">
    <p>def <span class="ident">accumulateClassList</span>(</p><p>classObj, attr, listObj, baseClass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Accumulate all attributes of a given name in a class
heirarchy into a single list. Assuming all class attributes
of this name are lists.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.accumulateClassList', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.accumulateClassList" class="source">
    <pre><code>def accumulateClassList(classObj, attr, listObj, baseClass=None):
    """Accumulate all attributes of a given name in a class
        heirarchy into a single list. Assuming all class attributes
        of this name are lists.
    """
    for base in classObj.__bases__:
        accumulateClassList(base, attr, listObj)
    if baseClass is None or baseClass in classObj.__bases__:
        listObj.extend(classObj.__dict__.get(attr, []))
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.addMethodNamesToDict">
    <p>def <span class="ident">addMethodNamesToDict</span>(</p><p>classObj, dict, prefix, baseClass=None)</p>
    </div>
    

    
  
    <div class="desc"><p>addMethodNamesToDict(classObj, dict, prefix, baseClass=None) -&gt; dict
this goes through 'classObj' (and its bases) and puts method names
starting with 'prefix' in 'dict' with a value of 1. if baseClass isn't
None, methods will only be added if classObj is-a baseClass</p>
<p>If the class in question has the methods 'prefix_methodname' and
'prefix_methodname2', the resulting dict should look something like:
{"methodname": 1, "methodname2": 1}.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.addMethodNamesToDict', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.addMethodNamesToDict" class="source">
    <pre><code>def addMethodNamesToDict(classObj, dict, prefix, baseClass=None):
    """
    addMethodNamesToDict(classObj, dict, prefix, baseClass=None) -> dict
    this goes through 'classObj' (and its bases) and puts method names
    starting with 'prefix' in 'dict' with a value of 1. if baseClass isn't
    None, methods will only be added if classObj is-a baseClass

    If the class in question has the methods 'prefix_methodname' and
    'prefix_methodname2', the resulting dict should look something like:
    {"methodname": 1, "methodname2": 1}.
    """
    for base in classObj.__bases__:
        addMethodNamesToDict(base, dict, prefix, baseClass)

    if baseClass is None or baseClass in classObj.__bases__:
        for name, method in classObj.__dict__.items():
            optName = name[len(prefix):]
            if ((type(method) is types.FunctionType)
                and (name[:len(prefix)] == prefix)
                and (len(optName))):
                dict[optName] = 1
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.filenameToModuleName">
    <p>def <span class="ident">filenameToModuleName</span>(</p><p>fn)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert a name in the filesystem to the name of the Python module it is.</p>
<p>This is agressive about getting a module name back from a file; it will
always return a string.  Agressive means 'sometimes wrong'; it won't look
at the Python path or try to do any error checking: don't use this method
unless you already know that the filename you're talking about is a Python
module.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.filenameToModuleName', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.filenameToModuleName" class="source">
    <pre><code>def filenameToModuleName(fn):
    """
    Convert a name in the filesystem to the name of the Python module it is.

    This is agressive about getting a module name back from a file; it will
    always return a string.  Agressive means 'sometimes wrong'; it won't look
    at the Python path or try to do any error checking: don't use this method
    unless you already know that the filename you're talking about is a Python
    module.
    """
    fullName = os.path.abspath(fn)
    base = os.path.basename(fn)
    if not base:
        # this happens when fn ends with a path separator, just skit it
        base = os.path.basename(fn[:-1])
    modName = os.path.splitext(base)[0]
    while 1:
        fullName = os.path.dirname(fullName)
        if os.path.exists(os.path.join(fullName, "__init__.py")):
            modName = "%s.%s" % (os.path.basename(fullName), modName)
        else:
            break
    return modName
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.findInstances">
    <p>def <span class="ident">findInstances</span>(</p><p>start, t)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.findInstances', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.findInstances" class="source">
    <pre><code>def findInstances(start, t):
    return objgrep(start, t, isOfType)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.fullFuncName">
    <p>def <span class="ident">fullFuncName</span>(</p><p>func)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.fullFuncName', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.fullFuncName" class="source">
    <pre><code>def fullFuncName(func):
    qualName = (str(pickle.whichmodule(func, func.__name__)) + '.' + func.__name__)
    if namedObject(qualName) is not func:
        raise Exception("Couldn't find %s as %s." % (func, qualName))
    return qualName
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.funcinfo">
    <p>def <span class="ident">funcinfo</span>(</p><p>function)</p>
    </div>
    

    
  
    <div class="desc"><p>this is more documentation for myself than useful code.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.funcinfo', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.funcinfo" class="source">
    <pre><code>def funcinfo(function):
    """
    this is more documentation for myself than useful code.
    """
    warnings.warn(
        "[v2.5] Use inspect.getargspec instead of twisted.python.reflect.funcinfo",
        DeprecationWarning,
        stacklevel=2)
    code=function.func_code
    name=function.func_name
    argc=code.co_argcount
    argv=code.co_varnames[:argc]
    defaults=function.func_defaults

    out = []

    out.append('The function %s accepts %s arguments' % (name ,argc))
    if defaults:
        required=argc-len(defaults)
        out.append('It requires %s arguments' % required)
        out.append('The arguments required are: %s' % argv[:required])
        out.append('additional arguments are:')
        for i in range(argc-required):
            j=i+required
            out.append('%s which has a default of' % (argv[j], defaults[i]))
    return out
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.getClass">
    <p>def <span class="ident">getClass</span>(</p><p>obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the class or type of object 'obj'.
Returns sensible result for oldstyle and newstyle instances and types.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.getClass', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.getClass" class="source">
    <pre><code>def getClass(obj):
    """Return the class or type of object 'obj'.
    Returns sensible result for oldstyle and newstyle instances and types."""
    if hasattr(obj, '__class__'):
        return obj.__class__
    else:
        return type(obj)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.getcurrent">
    <p>def <span class="ident">getcurrent</span>(</p><p>clazz)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.getcurrent', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.getcurrent" class="source">
    <pre><code>def getcurrent(clazz):
    assert type(clazz) == types.ClassType, 'must be a class...'
    module = namedModule(clazz.__module__)
    currclass = getattr(module, clazz.__name__, None)
    if currclass is None:
        return clazz
    return currclass
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.isLike">
    <p>def <span class="ident">isLike</span>(</p><p>a, b)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.isLike', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.isLike" class="source">
    <pre><code>def isLike(a, b):
    return (a == b)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.isOfType">
    <p>def <span class="ident">isOfType</span>(</p><p>start, goal)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.isOfType', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.isOfType" class="source">
    <pre><code>def isOfType(start, goal):
    return ((type(start) is goal) or
            (isinstance(start, types.InstanceType) and
             start.__class__ is goal))
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.isSame">
    <p>def <span class="ident">isSame</span>(</p><p>a, b)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.isSame', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.isSame" class="source">
    <pre><code>def isSame(a, b):
    return (a is b)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.isinst">
    <p>def <span class="ident">isinst</span>(</p><p>inst, clazz)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.isinst', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.isinst" class="source">
    <pre><code>def isinst(inst,clazz):
    if type(inst) != types.InstanceType or type(clazz)!= types.ClassType:
        return isinstance(inst,clazz)
    cl = inst.__class__
    cl2 = getcurrent(cl)
    clazz = getcurrent(clazz)
    if issubclass(cl2,clazz):
        if cl == cl2:
            return WAS
        else:
            inst.__class__ = cl2
            return IS
    else:
        return ISNT
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.modgrep">
    <p>def <span class="ident">modgrep</span>(</p><p>goal)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.modgrep', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.modgrep" class="source">
    <pre><code>def modgrep(goal):
    return objgrep(sys.modules, goal, isLike, 'sys.modules')
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.namedAny">
    <p>def <span class="ident">namedAny</span>(</p><p>name)</p>
    </div>
    

    
  
    <div class="desc"><p>Retrieve a Python object by its fully qualified name from the global Python
module namespace.  The first part of the name, that describes a module,
will be discovered and imported.  Each subsequent part of the name is
treated as the name of an attribute of the object specified by all of the
name which came before it.  For example, the fully-qualified name of this
object is 'twisted.python.reflect.namedAny'.</p>
<p>@type name: L{str}
@param name: The name of the object to return.</p>
<p>@raise InvalidName: If the name is an empty string, starts or ends with
    a '.', or is otherwise syntactically incorrect.</p>
<p>@raise ModuleNotFound: If the name is syntactically correct but the
    module it specifies cannot be imported because it does not appear to
    exist.</p>
<p>@raise ObjectNotFound: If the name is syntactically correct, includes at
    least one '.', but the module it specifies cannot be imported because
    it does not appear to exist.</p>
<p>@raise AttributeError: If an attribute of an object along the way cannot be
    accessed, or a module along the way is not found.</p>
<p>@return: the Python object identified by 'name'.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.namedAny', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.namedAny" class="source">
    <pre><code>def namedAny(name):
    """
    Retrieve a Python object by its fully qualified name from the global Python
    module namespace.  The first part of the name, that describes a module,
    will be discovered and imported.  Each subsequent part of the name is
    treated as the name of an attribute of the object specified by all of the
    name which came before it.  For example, the fully-qualified name of this
    object is 'twisted.python.reflect.namedAny'.

    @type name: L{str}
    @param name: The name of the object to return.

    @raise InvalidName: If the name is an empty string, starts or ends with
        a '.', or is otherwise syntactically incorrect.

    @raise ModuleNotFound: If the name is syntactically correct but the
        module it specifies cannot be imported because it does not appear to
        exist.

    @raise ObjectNotFound: If the name is syntactically correct, includes at
        least one '.', but the module it specifies cannot be imported because
        it does not appear to exist.

    @raise AttributeError: If an attribute of an object along the way cannot be
        accessed, or a module along the way is not found.

    @return: the Python object identified by 'name'.
    """
    if not name:
        raise InvalidName('Empty module name')

    names = name.split('.')

    # if the name starts or ends with a '.' or contains '..', the __import__
    # will raise an 'Empty module name' error. This will provide a better error
    # message.
    if '' in names:
        raise InvalidName(
            "name must be a string giving a '.'-separated list of Python "
            "identifiers, not %r" % (name,))

    topLevelPackage = None
    moduleNames = names[:]
    while not topLevelPackage:
        if moduleNames:
            trialname = '.'.join(moduleNames)
            try:
                topLevelPackage = _importAndCheckStack(trialname)
            except _NoModuleFound:
                moduleNames.pop()
        else:
            if len(names) == 1:
                raise ModuleNotFound("No module named %r" % (name,))
            else:
                raise ObjectNotFound('%r does not name an object' % (name,))

    obj = topLevelPackage
    for n in names[1:]:
        obj = getattr(obj, n)

    return obj
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.namedClass">
    <p>def <span class="ident">namedClass</span>(</p><p>name)</p>
    </div>
    

    
  
    <div class="desc"><p>Get a fully named module-global object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.namedClass', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.namedClass" class="source">
    <pre><code>def namedObject(name):
    """Get a fully named module-global object.
    """
    classSplit = name.split('.')
    module = namedModule('.'.join(classSplit[:-1]))
    return getattr(module, classSplit[-1])
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.namedModule">
    <p>def <span class="ident">namedModule</span>(</p><p>name)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a module given its name.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.namedModule', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.namedModule" class="source">
    <pre><code>def namedModule(name):
    """Return a module given its name."""
    topLevel = __import__(name)
    packages = name.split(".")[1:]
    m = topLevel
    for p in packages:
        m = getattr(m, p)
    return m
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.namedObject">
    <p>def <span class="ident">namedObject</span>(</p><p>name)</p>
    </div>
    

    
  
    <div class="desc"><p>Get a fully named module-global object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.namedObject', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.namedObject" class="source">
    <pre><code>def namedObject(name):
    """Get a fully named module-global object.
    """
    classSplit = name.split('.')
    module = namedModule('.'.join(classSplit[:-1]))
    return getattr(module, classSplit[-1])
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.objgrep">
    <p>def <span class="ident">objgrep</span>(</p><p>start, goal, eq=&lt;function isLike at 0xb68ab33c&gt;, path=&#39;&#39;, paths=None, seen=None, showUnknowns=0, maxDepth=None)</p>
    </div>
    

    
  
    <div class="desc"><p>An insanely CPU-intensive process for finding stuff.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.objgrep', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.objgrep" class="source">
    <pre><code>def objgrep(start, goal, eq=isLike, path='', paths=None, seen=None, showUnknowns=0, maxDepth=None):
    '''An insanely CPU-intensive process for finding stuff.
    '''
    if paths is None:
        paths = []
    if seen is None:
        seen = {}
    if eq(start, goal):
        paths.append(path)
    if id(start) in seen:
        if seen[id(start)] is start:
            return
    if maxDepth is not None:
        if maxDepth == 0:
            return
        maxDepth -= 1
    seen[id(start)] = start
    if isinstance(start, types.DictionaryType):
        for k, v in start.items():
            objgrep(k, goal, eq,
                    path + '{' + repr(v) + '}', paths,
                    seen, showUnknowns, maxDepth)
            objgrep(v, goal, eq, path+'[' + repr(k) + ']',
                    paths, seen, showUnknowns, maxDepth)
    elif isinstance(start, (list, tuple, deque)):
        for idx in xrange(len(start)):
            objgrep(
                start[idx], goal, eq, path+'[' + str(idx) + ']',
                paths, seen, showUnknowns, maxDepth)
    elif isinstance(start, types.MethodType):
        objgrep(start.im_self, goal, eq, path + '.im_self',
                paths, seen, showUnknowns, maxDepth)
        objgrep(start.im_func, goal, eq, path + '.im_func',
                paths, seen, showUnknowns, maxDepth)
        objgrep(start.im_class, goal, eq, path + '.im_class',
                paths, seen, showUnknowns, maxDepth)
    elif hasattr(start, '__dict__'):
        for k, v in start.__dict__.items():
            objgrep(v, goal, eq, path+'.' + k, paths, seen,
                    showUnknowns, maxDepth)
        if isinstance(start, types.InstanceType):
            objgrep(start.__class__, goal, eq,
                    path + '.__class__', paths,
                    seen, showUnknowns, maxDepth)
    elif isinstance(start, weakref.ReferenceType):
        objgrep(start(), goal, eq, path + '()', paths,
                seen, showUnknowns, maxDepth)
    elif (isinstance(start, types.StringTypes +\
                     (types.IntType, types.FunctionType,
                      types.BuiltinMethodType, RegexType, types.FloatType,
                      types.NoneType, types.FileType)) or
          type(start).__name__ in ('wrapper_descriptor', 'method_descriptor',
                                   'member_descriptor', 'getset_descriptor')):
        pass
    elif showUnknowns:
        print 'unknown type', type(start), start
    return paths
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.prefixedMethodNames">
    <p>def <span class="ident">prefixedMethodNames</span>(</p><p>classObj, prefix)</p>
    </div>
    

    
  
    <div class="desc"><p>A list of method names with a given prefix in a given class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.prefixedMethodNames', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.prefixedMethodNames" class="source">
    <pre><code>def prefixedMethodNames(classObj, prefix):
    """A list of method names with a given prefix in a given class.
    """
    dct = {}
    addMethodNamesToDict(classObj, dct, prefix)
    return dct.keys()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.prefixedMethods">
    <p>def <span class="ident">prefixedMethods</span>(</p><p>obj, prefix=&#39;&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>A list of methods with a given prefix on a given instance.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.prefixedMethods', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.prefixedMethods" class="source">
    <pre><code>def prefixedMethods(obj, prefix=''):
    """A list of methods with a given prefix on a given instance.
    """
    dct = {}
    accumulateMethods(obj, dct, prefix)
    return dct.values()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.qual">
    <p>def <span class="ident">qual</span>(</p><p>clazz)</p>
    </div>
    

    
  
    <div class="desc"><p>Return full import path of a class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.qual', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.qual" class="source">
    <pre><code>def qual(clazz):
    """Return full import path of a class."""
    return clazz.__module__ + '.' + clazz.__name__
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.safe_repr">
    <p>def <span class="ident">safe_repr</span>(</p><p>o)</p>
    </div>
    

    
  
    <div class="desc"><p>safe_repr(anything) -&gt; string</p>
<p>Returns a string representation of an object, or a string containing a
traceback, if that object's <strong>repr</strong> raised an exception.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.safe_repr', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.safe_repr" class="source">
    <pre><code>def safe_repr(o):
    """
    safe_repr(anything) -> string

    Returns a string representation of an object, or a string containing a
    traceback, if that object's __repr__ raised an exception.
    """
    return _safeFormat(repr, o)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="goulash.reflect.safe_str">
    <p>def <span class="ident">safe_str</span>(</p><p>o)</p>
    </div>
    

    
  
    <div class="desc"><p>safe_str(anything) -&gt; string</p>
<p>Returns a string representation of an object, or a string containing a
traceback, if that object's <strong>str</strong> raised an exception.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.safe_str', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.safe_str" class="source">
    <pre><code>def safe_str(o):
    """
    safe_str(anything) -> string

    Returns a string representation of an object, or a string containing a
    traceback, if that object's __str__ raised an exception.
    """
    return _safeFormat(str, o)
</code></pre>
  </div>
</div>

  </div>
  

    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="goulash.reflect.Accessor" class="name">class <span class="ident">Accessor</span></p>
      
  
    <div class="desc"><p>Extending this class will give you explicit accessor methods; a
method called C{set_foo}, for example, is the same as an if statement
in L{<strong>setattr</strong>} looking for C{'foo'}.  Same for C{get_foo} and
C{del_foo}.  There are also L{reallyDel} and L{reallySet} methods,
so you can override specifics in subclasses without clobbering
L{<strong>setattr</strong>} and L{<strong>getattr</strong>}.</p>
<p>This implementation is for Python 2.1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Accessor', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Accessor" class="source">
    <pre><code>class Accessor:
    """
    Extending this class will give you explicit accessor methods; a
    method called C{set_foo}, for example, is the same as an if statement
    in L{__setattr__} looking for C{'foo'}.  Same for C{get_foo} and
    C{del_foo}.  There are also L{reallyDel} and L{reallySet} methods,
    so you can override specifics in subclasses without clobbering
    L{__setattr__} and L{__getattr__}.

    This implementation is for Python 2.1.
    """

    def __setattr__(self, k,v):
        kstring='set_%s'%k
        if hasattr(self.__class__,kstring):
            return getattr(self,kstring)(v)
        else:
            self.reallySet(k,v)

    def __getattr__(self, k):
        kstring='get_%s'%k
        if hasattr(self.__class__,kstring):
            return getattr(self,kstring)()
        raise AttributeError("%s instance has no accessor for: %s" % (qual(self.__class__),k))

    def __delattr__(self, k):
        kstring='del_%s'%k
        if hasattr(self.__class__,kstring):
            getattr(self,kstring)()
            return
        self.reallyDel(k)

    def reallySet(self, k,v):
        """
        *actually* set self.k to v without incurring side-effects.
        This is a hook to be overridden by subclasses.
        """
        if k == "__dict__":
            self.__dict__.clear()
            self.__dict__.update(v)
        else:
            self.__dict__[k]=v

    def reallyDel(self, k):
        """
        *actually* del self.k without incurring side-effects.  This is a
        hook to be overridden by subclasses.
        """
        del self.__dict__[k]
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.Accessor">Accessor</a></li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="goulash.reflect.Accessor.reallyDel">
    <p>def <span class="ident">reallyDel</span>(</p><p>self, k)</p>
    </div>
    

    
  
    <div class="desc"><p><em>actually</em> del self.k without incurring side-effects.  This is a
hook to be overridden by subclasses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Accessor.reallyDel', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Accessor.reallyDel" class="source">
    <pre><code>def reallyDel(self, k):
    """
    *actually* del self.k without incurring side-effects.  This is a
    hook to be overridden by subclasses.
    """
    del self.__dict__[k]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="goulash.reflect.Accessor.reallySet">
    <p>def <span class="ident">reallySet</span>(</p><p>self, k, v)</p>
    </div>
    

    
  
    <div class="desc"><p><em>actually</em> set self.k to v without incurring side-effects.
This is a hook to be overridden by subclasses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Accessor.reallySet', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Accessor.reallySet" class="source">
    <pre><code>def reallySet(self, k,v):
    """
    *actually* set self.k to v without incurring side-effects.
    This is a hook to be overridden by subclasses.
    """
    if k == "__dict__":
        self.__dict__.clear()
        self.__dict__.update(v)
    else:
        self.__dict__[k]=v
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.AccessorType" class="name">class <span class="ident">AccessorType</span></p>
      
  
    <div class="desc"><p>Metaclass that generates properties automatically.</p>
<p>This is for Python 2.2 and up.</p>
<p>Using this metaclass for your class will give you explicit accessor
methods; a method called set_foo, will automatically create a property
'foo' that uses set_foo as a setter method. Same for get_foo and del_foo.</p>
<p>Note that this will only work on methods that are present on class
creation. If you add methods after the class is defined they will not
automatically become properties. Likewise, class attributes will only
be used if they are present upon class creation, and no getter function
was set - if a getter is present, the class attribute will be ignored.</p>
<p>This is a 2.2-only alternative to the Accessor mixin - just set in your
class definition::</p>
<pre><code>__metaclass__ = AccessorType
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.AccessorType', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.AccessorType" class="source">
    <pre><code>class AccessorType(type):
    """Metaclass that generates properties automatically.

    This is for Python 2.2 and up.

    Using this metaclass for your class will give you explicit accessor
    methods; a method called set_foo, will automatically create a property
    'foo' that uses set_foo as a setter method. Same for get_foo and del_foo.

    Note that this will only work on methods that are present on class
    creation. If you add methods after the class is defined they will not
    automatically become properties. Likewise, class attributes will only
    be used if they are present upon class creation, and no getter function
    was set - if a getter is present, the class attribute will be ignored.

    This is a 2.2-only alternative to the Accessor mixin - just set in your
    class definition::

        __metaclass__ = AccessorType

    """

    def __init__(self, name, bases, d):
        type.__init__(self, name, bases, d)
        accessors = {}
        prefixs = ["get_", "set_", "del_"]
        for k in d.keys():
            v = getattr(self, k)
            for i in range(3):
                if k.startswith(prefixs[i]):
                    accessors.setdefault(k[4:], [None, None, None])[i] = v
        for name, (getter, setter, deler) in accessors.items():
            # create default behaviours for the property - if we leave
            # the getter as None we won't be able to getattr, etc..
            if getter is None:
                if hasattr(self, name):
                    value = getattr(self, name)
                    def getter(this, value=value, name=name):
                        if name in this.__dict__:
                            return this.__dict__[name]
                        else:
                            return value
                else:
                    def getter(this, name=name):
                        if name in this.__dict__:
                            return this.__dict__[name]
                        else:
                            raise AttributeError("no such attribute %r" % name)
            if setter is None:
                def setter(this, value, name=name):
                    this.__dict__[name] = value
            if deler is None:
                def deler(this, name=name):
                    del this.__dict__[name]
            setattr(self, name, property(getter, setter, deler, ""))
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.AccessorType">AccessorType</a></li>
          <li>__builtin__.type</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="goulash.reflect.AccessorType.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name, bases, d)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.AccessorType.__init__', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.AccessorType.__init__" class="source">
    <pre><code>def __init__(self, name, bases, d):
    type.__init__(self, name, bases, d)
    accessors = {}
    prefixs = ["get_", "set_", "del_"]
    for k in d.keys():
        v = getattr(self, k)
        for i in range(3):
            if k.startswith(prefixs[i]):
                accessors.setdefault(k[4:], [None, None, None])[i] = v
    for name, (getter, setter, deler) in accessors.items():
        # create default behaviours for the property - if we leave
        # the getter as None we won't be able to getattr, etc..
        if getter is None:
            if hasattr(self, name):
                value = getattr(self, name)
                def getter(this, value=value, name=name):
                    if name in this.__dict__:
                        return this.__dict__[name]
                    else:
                        return value
            else:
                def getter(this, name=name):
                    if name in this.__dict__:
                        return this.__dict__[name]
                    else:
                        raise AttributeError("no such attribute %r" % name)
        if setter is None:
            def setter(this, value, name=name):
                this.__dict__[name] = value
        if deler is None:
            def deler(this, name=name):
                del this.__dict__[name]
        setattr(self, name, property(getter, setter, deler, ""))
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.InvalidName" class="name">class <span class="ident">InvalidName</span></p>
      
  
    <div class="desc"><p>The given name is not a dot-separated list of Python objects.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.InvalidName', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.InvalidName" class="source">
    <pre><code>class InvalidName(ValueError):
    """
    The given name is not a dot-separated list of Python objects.
    """
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.InvalidName">InvalidName</a></li>
          <li>exceptions.ValueError</li>
          <li>exceptions.StandardError</li>
          <li>exceptions.Exception</li>
          <li>exceptions.BaseException</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="goulash.reflect.InvalidName.args" class="name">var <span class="ident">args</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="goulash.reflect.InvalidName.message" class="name">var <span class="ident">message</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.ModuleNotFound" class="name">class <span class="ident">ModuleNotFound</span></p>
      
  
    <div class="desc"><p>The module associated with the given name doesn't exist and it can't be
imported.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.ModuleNotFound', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.ModuleNotFound" class="source">
    <pre><code>class ModuleNotFound(InvalidName):
    """
    The module associated with the given name doesn't exist and it can't be
    imported.
    """
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.ModuleNotFound">ModuleNotFound</a></li>
          <li><a href="#goulash.reflect.InvalidName">InvalidName</a></li>
          <li>exceptions.ValueError</li>
          <li>exceptions.StandardError</li>
          <li>exceptions.Exception</li>
          <li>exceptions.BaseException</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="goulash.reflect.ModuleNotFound.args" class="name">var <span class="ident">args</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#goulash.reflect.InvalidName">InvalidName</a></code>.<code><a href="#goulash.reflect.InvalidName.args">args</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="goulash.reflect.ModuleNotFound.message" class="name">var <span class="ident">message</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#goulash.reflect.InvalidName">InvalidName</a></code>.<code><a href="#goulash.reflect.InvalidName.message">message</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.ObjectNotFound" class="name">class <span class="ident">ObjectNotFound</span></p>
      
  
    <div class="desc"><p>The object associated with the given name doesn't exist and it can't be
imported.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.ObjectNotFound', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.ObjectNotFound" class="source">
    <pre><code>class ObjectNotFound(InvalidName):
    """
    The object associated with the given name doesn't exist and it can't be
    imported.
    """
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.ObjectNotFound">ObjectNotFound</a></li>
          <li><a href="#goulash.reflect.InvalidName">InvalidName</a></li>
          <li>exceptions.ValueError</li>
          <li>exceptions.StandardError</li>
          <li>exceptions.Exception</li>
          <li>exceptions.BaseException</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="goulash.reflect.ObjectNotFound.args" class="name">var <span class="ident">args</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#goulash.reflect.InvalidName">InvalidName</a></code>.<code><a href="#goulash.reflect.InvalidName.args">args</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="goulash.reflect.ObjectNotFound.message" class="name">var <span class="ident">message</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#goulash.reflect.InvalidName">InvalidName</a></code>.<code><a href="#goulash.reflect.InvalidName.message">message</a></code>
    </p>

            
  
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.Accessor" class="name">class <span class="ident">OriginalAccessor</span></p>
      
  
    <div class="desc"><p>Extending this class will give you explicit accessor methods; a
method called C{set_foo}, for example, is the same as an if statement
in L{<strong>setattr</strong>} looking for C{'foo'}.  Same for C{get_foo} and
C{del_foo}.  There are also L{reallyDel} and L{reallySet} methods,
so you can override specifics in subclasses without clobbering
L{<strong>setattr</strong>} and L{<strong>getattr</strong>}.</p>
<p>This implementation is for Python 2.1.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Accessor', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Accessor" class="source">
    <pre><code>class Accessor:
    """
    Extending this class will give you explicit accessor methods; a
    method called C{set_foo}, for example, is the same as an if statement
    in L{__setattr__} looking for C{'foo'}.  Same for C{get_foo} and
    C{del_foo}.  There are also L{reallyDel} and L{reallySet} methods,
    so you can override specifics in subclasses without clobbering
    L{__setattr__} and L{__getattr__}.

    This implementation is for Python 2.1.
    """

    def __setattr__(self, k,v):
        kstring='set_%s'%k
        if hasattr(self.__class__,kstring):
            return getattr(self,kstring)(v)
        else:
            self.reallySet(k,v)

    def __getattr__(self, k):
        kstring='get_%s'%k
        if hasattr(self.__class__,kstring):
            return getattr(self,kstring)()
        raise AttributeError("%s instance has no accessor for: %s" % (qual(self.__class__),k))

    def __delattr__(self, k):
        kstring='del_%s'%k
        if hasattr(self.__class__,kstring):
            getattr(self,kstring)()
            return
        self.reallyDel(k)

    def reallySet(self, k,v):
        """
        *actually* set self.k to v without incurring side-effects.
        This is a hook to be overridden by subclasses.
        """
        if k == "__dict__":
            self.__dict__.clear()
            self.__dict__.update(v)
        else:
            self.__dict__[k]=v

    def reallyDel(self, k):
        """
        *actually* del self.k without incurring side-effects.  This is a
        hook to be overridden by subclasses.
        """
        del self.__dict__[k]
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.Accessor">Accessor</a></li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="goulash.reflect.Accessor.reallyDel">
    <p>def <span class="ident">reallyDel</span>(</p><p>self, k)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#goulash.reflect.Accessor">Accessor</a></code>.<code><a href="#goulash.reflect.Accessor.reallyDel">reallyDel</a></code>
    </p>

    
  
    <div class="desc inherited"><p><em>actually</em> del self.k without incurring side-effects.  This is a
hook to be overridden by subclasses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Accessor.reallyDel', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Accessor.reallyDel" class="source">
    <pre><code>def reallyDel(self, k):
    """
    *actually* del self.k without incurring side-effects.  This is a
    hook to be overridden by subclasses.
    """
    del self.__dict__[k]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="goulash.reflect.Accessor.reallySet">
    <p>def <span class="ident">reallySet</span>(</p><p>self, k, v)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#goulash.reflect.Accessor">Accessor</a></code>.<code><a href="#goulash.reflect.Accessor.reallySet">reallySet</a></code>
    </p>

    
  
    <div class="desc inherited"><p><em>actually</em> set self.k to v without incurring side-effects.
This is a hook to be overridden by subclasses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Accessor.reallySet', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Accessor.reallySet" class="source">
    <pre><code>def reallySet(self, k,v):
    """
    *actually* set self.k to v without incurring side-effects.
    This is a hook to be overridden by subclasses.
    """
    if k == "__dict__":
        self.__dict__.clear()
        self.__dict__.update(v)
    else:
        self.__dict__[k]=v
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.PropertyAccessor" class="name">class <span class="ident">PropertyAccessor</span></p>
      
  
    <div class="desc"><p>A mixin class for Python 2.2 that uses AccessorType.</p>
<p>This provides compatability with the pre-2.2 Accessor mixin, up
to a point.</p>
<p>Extending this class will give you explicit accessor methods; a
method called set_foo, for example, is the same as an if statement
in <strong>setattr</strong> looking for 'foo'.  Same for get_foo and del_foo.</p>
<p>There are also reallyDel and reallySet methods, so you can
override specifics in subclasses without clobbering <strong>setattr</strong>
and <strong>getattr</strong>, or using non-2.1 compatible code.</p>
<p>There is are incompatibilities with Accessor - accessor
methods added after class creation will <em>not</em> be detected. OTOH,
this method is probably way faster.</p>
<p>In addition, class attributes will only be used if no getter
was defined, and instance attributes will not override getter methods
whereas in original Accessor the class attribute or instance attribute
would override the getter method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.PropertyAccessor', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.PropertyAccessor" class="source">
    <pre><code>class PropertyAccessor(object):
    """A mixin class for Python 2.2 that uses AccessorType.

    This provides compatability with the pre-2.2 Accessor mixin, up
    to a point.

    Extending this class will give you explicit accessor methods; a
    method called set_foo, for example, is the same as an if statement
    in __setattr__ looking for 'foo'.  Same for get_foo and del_foo.

    There are also reallyDel and reallySet methods, so you can
    override specifics in subclasses without clobbering __setattr__
    and __getattr__, or using non-2.1 compatible code.

    There is are incompatibilities with Accessor - accessor
    methods added after class creation will *not* be detected. OTOH,
    this method is probably way faster.

    In addition, class attributes will only be used if no getter
    was defined, and instance attributes will not override getter methods
    whereas in original Accessor the class attribute or instance attribute
    would override the getter method.
    """
    # addendum to above:
    # The behaviour of Accessor is wrong IMHO, and I've found bugs
    # caused by it.
    #  -- itamar

    __metaclass__ = AccessorType

    def reallySet(self, k, v):
        self.__dict__[k] = v

    def reallyDel(self, k):
        del self.__dict__[k]
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.PropertyAccessor">PropertyAccessor</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="goulash.reflect.PropertyAccessor.reallyDel">
    <p>def <span class="ident">reallyDel</span>(</p><p>self, k)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.PropertyAccessor.reallyDel', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.PropertyAccessor.reallyDel" class="source">
    <pre><code>def reallyDel(self, k):
    del self.__dict__[k]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="goulash.reflect.PropertyAccessor.reallySet">
    <p>def <span class="ident">reallySet</span>(</p><p>self, k, v)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.PropertyAccessor.reallySet', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.PropertyAccessor.reallySet" class="source">
    <pre><code>def reallySet(self, k, v):
    self.__dict__[k] = v
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.QueueMethod" class="name">class <span class="ident">QueueMethod</span></p>
      
  
    <div class="desc"><p>I represent a method that doesn't exist yet.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.QueueMethod', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.QueueMethod" class="source">
    <pre><code>class QueueMethod:
    """ I represent a method that doesn't exist yet."""
    def __init__(self, name, calls):
        self.name = name
        self.calls = calls
    def __call__(self, *args):
        self.calls.append((self.name, args))
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.QueueMethod">QueueMethod</a></li>
          </ul>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="goulash.reflect.QueueMethod.calls" class="name">var <span class="ident">calls</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="goulash.reflect.QueueMethod.name" class="name">var <span class="ident">name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="goulash.reflect.QueueMethod.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name, calls)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.QueueMethod.__init__', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.QueueMethod.__init__" class="source">
    <pre><code>def __init__(self, name, calls):
    self.name = name
    self.calls = calls
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.Settable" class="name">class <span class="ident">Settable</span></p>
      
  
    <div class="desc"><p>A mixin class for syntactic sugar.  Lets you assign attributes by
calling with keyword arguments; for example, C{x(a=b,c=d,y=z)} is the
same as C{x.a=b;x.c=d;x.y=z}.  The most useful place for this is
where you don't want to name a variable, but you do want to set
some attributes; for example, C{X()(y=z,a=b)}.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Settable', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Settable" class="source">
    <pre><code>class Settable:
    """
    A mixin class for syntactic sugar.  Lets you assign attributes by
    calling with keyword arguments; for example, C{x(a=b,c=d,y=z)} is the
    same as C{x.a=b;x.c=d;x.y=z}.  The most useful place for this is
    where you don't want to name a variable, but you do want to set
    some attributes; for example, C{X()(y=z,a=b)}.
    """
    def __init__(self, **kw):
        self(**kw)

    def __call__(self,**kw):
        for key,val in kw.items():
            setattr(self,key,val)
        return self
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.Settable">Settable</a></li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="goulash.reflect.Settable.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, **kw)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Settable.__init__', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Settable.__init__" class="source">
    <pre><code>def __init__(self, **kw):
    self(**kw)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>
      
      <div class="item">
      <p id="goulash.reflect.Summer" class="name">class <span class="ident">Summer</span></p>
      
  
    <div class="desc"><p>Extend from this class to get the capability to maintain 'related
sums'.  Have a tuple in your class like the following::</p>
<pre><code>sums=(('amount','credit','credit_total'),
    ('amount','debit','debit_total'))
</code></pre>
<p>and the 'credit_total' member of the 'credit' member of self will
always be incremented when the 'amount' member of self is
incremented, similiarly for the debit versions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Summer', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Summer" class="source">
    <pre><code>class Summer(Accessor):
    """
    Extend from this class to get the capability to maintain 'related
    sums'.  Have a tuple in your class like the following::

        sums=(('amount','credit','credit_total'),
            ('amount','debit','debit_total'))

    and the 'credit_total' member of the 'credit' member of self will
    always be incremented when the 'amount' member of self is
    incremented, similiarly for the debit versions.
    """

    def reallySet(self, k,v):
        "This method does the work."
        for sum in self.sums:
            attr=sum[0]
            obj=sum[1]
            objattr=sum[2]
            if k == attr:
                try:
                    oldval=getattr(self, attr)
                except:
                    oldval=0
                diff=v-oldval
                if hasattr(self, obj):
                    ob=getattr(self,obj)
                    if ob is not None:
                        try:oldobjval=getattr(ob, objattr)
                        except:oldobjval=0.0
                        setattr(ob,objattr,oldobjval+diff)

            elif k == obj:
                if hasattr(self, attr):
                    x=getattr(self,attr)
                    setattr(self,attr,0)
                    y=getattr(self,k)
                    Accessor.reallySet(self,k,v)
                    setattr(self,attr,x)
                    Accessor.reallySet(self,y,v)
        Accessor.reallySet(self,k,v)
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#goulash.reflect.Summer">Summer</a></li>
          <li><a href="#goulash.reflect.Accessor">Accessor</a></li>
          </ul>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="goulash.reflect.Summer.reallyDel">
    <p>def <span class="ident">reallyDel</span>(</p><p>self, k)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#goulash.reflect.Accessor">Accessor</a></code>.<code><a href="#goulash.reflect.Accessor.reallyDel">reallyDel</a></code>
    </p>

    
  
    <div class="desc inherited"><p><em>actually</em> del self.k without incurring side-effects.  This is a
hook to be overridden by subclasses.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Summer.reallyDel', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Summer.reallyDel" class="source">
    <pre><code>def reallyDel(self, k):
    """
    *actually* del self.k without incurring side-effects.  This is a
    hook to be overridden by subclasses.
    """
    del self.__dict__[k]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="goulash.reflect.Summer.reallySet">
    <p>def <span class="ident">reallySet</span>(</p><p>self, k, v)</p>
    </div>
    
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#goulash.reflect.Accessor">Accessor</a></code>.<code><a href="#goulash.reflect.Accessor.reallySet">reallySet</a></code>
    </p>

    
  
    <div class="desc"><p>This method does the work.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-goulash.reflect.Summer.reallySet', this);">Show source &equiv;</a></p>
  <div id="source-goulash.reflect.Summer.reallySet" class="source">
    <pre><code>def reallySet(self, k,v):
    "This method does the work."
    for sum in self.sums:
        attr=sum[0]
        obj=sum[1]
        objattr=sum[2]
        if k == attr:
            try:
                oldval=getattr(self, attr)
            except:
                oldval=0
            diff=v-oldval
            if hasattr(self, obj):
                ob=getattr(self,obj)
                if ob is not None:
                    try:oldobjval=getattr(ob, objattr)
                    except:oldobjval=0.0
                    setattr(ob,objattr,oldobjval+diff)
        elif k == obj:
            if hasattr(self, attr):
                x=getattr(self,attr)
                setattr(self,attr,0)
                y=getattr(self,k)
                Accessor.reallySet(self,k,v)
                setattr(self,attr,x)
                Accessor.reallySet(self,y,v)
    Accessor.reallySet(self,k,v)
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
